---
layout: post
title: 'F√§n Stuff for free'
date: 2025-07-03
category: code
tags:
  - projekt
  - code
  - jekyll
image: 'assets/images/blog/2025-07-03-fan-stuff_cover.png'
description: 'Aus Mangel an DIE √ÑRZTE-Fan-Shirts f√ºr Frauen bin ich kreativ geworden.'
---

Wer mich ein bisschen kennt, wei√ü dass ich so ziemlich jeden Song von der _b√§sten B√§nd der Welt_ auswendig kann. Aber auch, dass ich noch nie mit einem Fan-Shirt gesehen wurde. Nicht einmal auf Konzerten!

Das liegt daran, dass die Auswahl im offiziellen Die √Ñrzte Fanshop f√ºr Frauen sehr mau ausf√§llt. Das hei√üt: Es gibt genau EIN Unisex-Shirt. Also habe ich einfach selber ein paar Designs erstellt, und die gibt's hier for free zum Herunterladen: [https://f√§n-stuff.de/](https://f√§n-stuff.de/)

![Screenshot der Website f√§n-stuff.de, zu sehen sind Designs f√ºr Shirts zum Herunterladen](/assets/images/blog/fan-stuff/fan-designs.png)

Die Website dazu habe ich nat√ºrlich selber geschrieben ‚Äì mit sch√∂nem, sauberen Code. Es gibt sogar eine _Songzeile des Tages_, die (wie der Name vermuten l√§sst) sich jeden Tag √§ndert.

![Screenshot der Website f√§n-stuff.de, zu sehen ist die Songzeile des Tages](/assets/images/blog/fan-stuff/songzeile-des-tages.png)

## Jekyll mit Liquid-Logik

Im ersten Anlauf habe ich das Ganze rein statisch mit **Jekyll** und einem feinen Liquid-Hack gel√∂st. Daf√ºr habe ich zuerst eine Datei mit Songzeilen erstellt. In `_data/sprueche.yml` sieht der Eintrag f√ºr einen Song so aus:

```yaml
- text: 'Die Welt geh√∂rt dir: Was wirst du mit ihr machen?'
  title: 'Himmelblau'
  url: 'https://www.bademeister.com/songs/himmelblau'
```

Der Trick: ich nutze das Datum als Index, modulo der Anzahl der Spr√ºche. In meiner `index.html` nutze ich daf√ºr den folgenden Code-Schnipsel:

{% raw %}

```liquid
{% assign sprueche = site.data.sprueche %}
{% assign today = site.time | date: "%j" %}  {# Tag im Jahr: 1 bis 366 #}
{% assign index = today | modulo: sprueche.size %}
<p>{{ sprueche[index] }}</p>
```

{% endraw %}

- `site.time | date: "%j"` ‚Üí gibt mir den aktuellen Tag im Jahr (z.‚ÄØB. Tag 172).
- `modulo: sprueche.size` ‚Üí sorgt daf√ºr, dass ich nicht aus Versehen aus der Liste herausfalle.
- `sprueche[index]` ‚Üí holt den passenden Spruch.

Das funktioniert super, allerdings mit einem kleinen Haken.

## Dann doch JavaScript

Letztlich habe ich es doch auf die klassische Art mit JavaScript gel√∂st.

Warum? Weil GitHub Pages statisch ist, das hei√üt: Es wird immer dieselbe HTML-Seite ausgeliefert. Und da Jekyll nur beim Build rendert (also z.‚ÄØB. beim Pushen oder Deployen), bleibt die _Songzeile des Tages_ √ºber die ganze Zeit hinweg gleich, solange bis ich manuell pushe. Nicht ganz das, was ich mir vorgestellt hatte.

Mit JavaScript kann ich das direkt im Browser erledigen. Die Seite fragt dann lokal beim Laden: _Hey, du, welcher Tag ist heute?_ und w√§hlt on the fly einen passenden Song aus der Liste aus.

## Die Funktionen im Detail

### `pickSong(songliste)`

Diese Funktion sorgt daf√ºr, dass t√§glich ein anderer Song basierend auf dem aktuellen Datum angezeigt wird.

Dazu wird erst das heutige Datum ermittelt und mit dem Jahresanfang (dem 0. Januar) verglichen. Daraus ergibt sich, wie viele Tage seit Jahresbeginn vergangen sind. Diese Tageszahl wird dann als Basis genommen, um einen Eintrag aus der Songliste auszuw√§hlen.

Damit nicht aus Versehen ein ung√ºltiger Eintrag aus der Liste geholt wird, wird ein kleiner Trick genutzt: Der aktuelle Tag im Jahr wird durch die Anzahl der Songs geteilt, und nur der Rest der Division wird verwendet (das nennt man _modulo_).

Wenn heute der 172. Tag im Jahr ist und du 20 Songs hast, dann:  
172 % 20 = 12  
Das ist das gleiche wie 172 / 20 = 8 Rest 12  
Also wird einfach der Song an Stelle 12 angezeigt.

So wird sichergestellt, dass der Index immer innerhalb der Songliste bleibt (weil das Ergebnis nie gr√∂√üer sein kann als die Anzahl an Songs).

```js
function pickSong(songliste) {
  const heute = new Date();
  const jahresbeginn = new Date(heute.getFullYear(), 0, 0);
  const differenz = heute - jahresbeginn;
  const tagDesJahres = Math.floor(differenz / 1000 / 60 / 60 / 24);
  const index = tagDesJahres % songliste.length;
  return songliste[index];
}
```

### `placeSongInHtml(song)`

Diese Funktion sorgt daf√ºr, dass die ausgew√§hlte Songzeile im HTML landet und sichtbar auf der Website erscheint. Oder ganz knapp: Die Funktion packt die Daten an die richtigen Stellen.

Daf√ºr nimmt sie ein `song`-Objekt entgegen (mit `text`, `title` und `url`) und verteilt diese Infos in die passenden HTML-Elemente:

- Der **Songtext** wird in das Element mit der ID `songzeile-text` geschrieben.
- Der **Titel** des Songs kommt in das Element mit der ID `songzeile-title`.
- Und der **Link**, z.‚ÄØB. zur Quelle oder zum Song selbst, wird im Element mit der ID `songzeile-link` hinterlegt.

{% raw %}

```js
function placeSongInHtml(song) {
  document.getElementById('songzeile-text').textContent = song.text;
  document.getElementById('songzeile-link').href = song.url;
  document.getElementById('songzeile-title').textContent = song.title;
}
```

{% endraw %}

### Und so kommt alles zusammen

Die Datei mit den Songzeilen wird per `fetch()` vom Server geladen:

{% raw %}

```js
fetch('/songs.json');
```

{% endraw %}

Sobald die Datei erfolgreich geladen wurde, wird sie mit `.json()` umgewandelt. Das ist wichtig damit wir sie √ºberhaupt weiterverarbeiten k√∂nnen:

{% raw %}

```js
.then(function (response) {
  return response.json();
})
```

{% endraw %}

Wenn das Parsen geklappt hat, wird die `pickSong`-Funktion aufgerufen:

{% raw %}

```js
.then(pickSong)
```

{% endraw %}

Und ganz zum Schluss sorgt `placeSongInHtml` daf√ºr, dass der ausgew√§hlte Song h√ºbsch im HTML angezeigt wird:

{% raw %}

```js
.then(placeSongInHtml);
```

{% endraw %}

Also: Erst **laden**, dann **umwandeln**, dann **ausw√§hlen**, dann **anzeigen**. Alles Schritt f√ºr Schritt und super lesbar verkettet durch `.then(...)`.

Falls du dich fragst, was es mit diesen `.then(...)`-Ketten eigentlich auf sich hat: Das geh√∂rt zur sogenannten **Promise-Logik** in JavaScript.

Das ist eine elegante Art, asynchrone Abl√§ufe Schritt f√ºr Schritt abzuarbeiten.
Jedes `.then(...)` wartet auf den vorherigen Schritt und f√ºhrt dann etwas aus. Ein bisschen verwirrend, doch keine Sorge: genau dazu gibt‚Äôs demn√§chst einen eigenen Blogbeitrag.

## Was ich au√üerdem gelernt habe

Umlaute im Domainnamen machen √Ñrger. Wenn die URL also bei dir im Browser irgendwie komisch aussieht: sei unbesorgt, das ist keine billige Phishing-Seite üê≥ Nein, das liegt daran, dass sie automatisch in Punycode √ºbersetzt wird. Das ist eine spezielle Kodierung. Sie erlaubt Umlaute und andere Sonderzeichen darzustellen. Denn das klassische Domain-Name-System (DNS) unterst√ºtzt nur ASCII-Zeichen (also Buchstaben a bis z, Zahlen und einige wenige Sonderzeichen).

In Punycode √ºbersetzt wird f√§n-stuff.de zu [xn--fn-stuff-0za.de](http://xn--fn-stuff-0za.de)

Gibt's hier auch √Ñrzte-Fans? üëÄ
